[toc]



# 七大设计原则

**框架等各种技术是“术”，设计模式这种知识是“道”。**

这 7 种设计原则是软件设计模式必须尽量遵循的原则，是设计模式的基础。在实际开发过程中，并不是一定要求所有代码都遵循设计原则，而是要综合考虑人力、时间、成本、质量，不刻意追求完美，要在适当的场景遵循设计原则。这体现的是一种平衡取舍，可以帮助我们设计出更加优雅的代码结构。

https://www.cnblogs.com/zhaye/p/11176906.html

| **设计原则**     | **一句话归纳**                                               | **目的**                                       |
| ---------------- | ------------------------------------------------------------ | ---------------------------------------------- |
| **开闭原则**     | **对扩展开放，对修改关闭**                                   | **降低维护带来的新风险**                       |
| **依赖倒置原则** | **高层不应该依赖低层，要面向接口编程**                       | **更利于代码结构的升级扩展**                   |
| **单一职责原则** | **一个类只干一件事，实现类要单一**                           | **便于理解，提高代码的可读性**                 |
| **接口隔离原则** | **一个接口只干一件事，接口要精简单一**                       | **功能解耦，高聚合、低耦合**                   |
| **迪米特法则**   | **不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度** | **只和朋友交流，不和陌生人说话，减少代码臃肿** |
| **里氏替换原则** | **不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义** | **防止继承泛滥**                               |
| **合成复用原则** | **尽量使用组合或者聚合关系实现代码复用，少使用继承**         | **降低代码耦合**                               |



## 开闭原则

> Software entities should be open for extension，but closed for modification.

开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则

一个软件实体，如类，模块和函数应该**对扩展开放（对提供方），对修改关闭（对使用方）**。**用抽象构建框架，用实现扩展细节。**

**当软件需要变化时，尽量通过扩展软件实体的行为来实现变化（新建实现类），而不是通过修改已有的代码来实现变化。**



**开闭原则的实现方法**

可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，**即当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。**



### 开闭原则coding举例

背景介绍：慕课网上的课程，有课程id，课程名，课程价格。课程分为各种Java、Python等多种类型。**面向接口编程，**应该先写课程的Interface，然后实现javaCourse，pythonCourse...

![img](设计原则.assets/clipboard.png)

**新的需求：打折活动，部分课程打折。**

方法1：在Course接口中增加方法：`getDiscountPrice()`，在实现类`javaCourse()`实现方法。

这种方法有什么问题？

**接口不应该经常变化，应该是稳定且可靠的。**



方法2：不修改接口。修改需要打折的`javaCourse`类中的`getPrice()`方法：

```java
@Override 
public Double getPrice() {
    return this.price * 0.8; 
}
```

问题：只是满足了这次需求。但是如果要显式原价呢？如果后序还有优惠券呢？



**真正满足开闭原则的方法：**

新建`JavaDiscountCourse extends JavaCourse`，重写`getPrice()`，获取打折后的打折，新增`getOriginalPrice()`，获取原价。

![img](设计原则.assets/clipboard.png)

**<font color=red>这样做的好处：</font>**

**没有修改接口和基类-对修改关闭，继承基类-对扩展开放。**不会影响接口和基类，本次需求不会影响之前的功能，并且不会影响其他模块的功能。

其他模块可能调用Course，互相依赖，如果改错了Course中的内容，会影响其他模块：团队开发是很多人共同写作的，每个人都上来改一下接口和Class，会越改越乱。而且可能一改就影响到别人的功能了，如果采用方法2，别人不知道你的修改，别人是要用Class返回原价，不就出错了么？

**对软件测试的影响：**软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。

其他好处：

**降低维护成本：**遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

**可以提高代码的可复用性**：粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。

<font color=blue>todo 通过BigDecimal解决丢失精度问题</font>



## 依赖倒置原则

> High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions

依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。理解依赖倒置原则，对于理解Spring的依赖注入，控制反转也有很大的帮助。

依赖倒置原则的原始定义为：**高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：<font color=red>要面向接口编程，不要面向实现编程。</font> 其主要目的是：降低耦合。**

高层指的是应用层Controller>Service层>DAO层

由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。

使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。



依赖倒置原则的主要作用如下：

- 降低修改程序所造成的风险。
- 降低类间的耦合性。
- 提高系统的稳定性。
- 提高代码的可读性和可维护性。



### 依赖倒置coding举例

一个底层对象Person，Person可以实现的功能有学习Java课程，学习Python课程，学习前端课程。

方法1：

![image-20210312234955675](设计原则.assets/image-20210312234955675.png)

直接在Person这个class中创建学习Java课程，学习Python课程，学习前端课程的方法。

应用层：

```java
    public static void main(String[] args) {
        Person tom = new Person();
        tom.studyGolangCourse();
        tom.studyJavaCourse();
    }
```

这就是面向实现编程，Person就是实现类，高层-应用层的依赖于底层的Person，应用层新增功能，都需要在Person类中去修改。比如想要再添加一个学习日语的功能，需要修改底层的Person。



**满足依赖倒置的写法：**

**方法1. 接口方法**

<img src="设计原则.assets/image-20210313000909525.png" alt="image-20210313000909525" style="zoom:80%;" />

面向接口编程：用Course接口，通过实现来增加课程。将Human和课程解耦，只需要传入Course作为Human中学习课程方法的参数。具体学习什么课程交给高层模块应用层Test来选择，Human和Test之间也是解耦的。

```java
	public static void main(String[] args) {
        Human human = new Human();
        human.studyCourse(new JavaCourse());
        human.studyCourse(new PythonCourse());
    }
```



**方法2. 构造方法Setter**

方法1Human和Course是依赖关系，也可以用关联关系。即让Human类持有Course对象，相当于Spring中的@autowired注入DAO层或service层的接口。

<img src="设计原则.assets/image-20210313002245977.png" alt="image-20210313002245977" style="zoom:80%;" />

```java
    public static void main(String[] args) {
        Human tom = new Human();
        tom.setCourse(new JavaCourse());
        tom.studyCourse();
        tom.setCourse(new PythonCourse());
        tom.studyCourse();
    }
```



这样做的好处：

Human是高层次模块，Course是低层次模块。Human这个类不依赖具体的PythonCourse或者JavaCourse，想学什么课，都可以在不动Human这个模块的前提下修改。新增课程，比如C++课程，Course也不需要动，只需要新增实现类即可，同样也满足开闭原则。





## 单一职责原则

